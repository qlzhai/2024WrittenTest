# 2024.4.18快手

## 1.矩阵最大路径

### 题目描述：

给定一个包含一个整数的MN的矩阵，请找出一条从左上角到右下角的路径，使得路径上的数字总和最大，每次只能向下或者向右移动一步，初始位置在 grid\[0][0]例如如下的短阵:

| 1    | 2    | 3    |
| ---- | ---- | ---- |
| 4    | 5    | 6    |
| 7    | 8    | 9    |

最大路径为：1+4+7+8+9=29

- 输入

  ```
  [143,145,423,-618,476,869,573,850,629)3,3
  ```

- 输出

  ```
  1957
  ```

### 分析

这道题目是一道典型的动态规划题目，本题与leetcode上第64题相似[64. 最小路径和 ](https://leetcode.cn/problems/minimum-path-sum/description/)，不同之处是64题是求最小路径和，本题是求最大路径和

- 设置一个二维的**dp**数组，**dp\[i][j]**表示从**grid\[0][0]**到**grid\[i][j]**所经过的最大距离

- 初始化**dp\[0][0]=grid\[0][0]**

- 由于每次只能向右或者向下移动一步，因此

  ```c++
  dp[i][0] = dp[i-1][0] + grid[i][j]//初始化dp的第一列
  dp[0][j] = dp[0][j-1] + grid[i][j]//初始化dp的第一行
  ```

- 确定递推公式

  **dp\[i][j] = 从[i,j]的左边向右移动到达[i,j]的距离 和 从[i,j]的上边向下移动到达[i,j]的距离 的最小值**

- 不过，个人认位本题还有另一个关键点，就是如何从输入的数据中解析出关联矩阵。

### 代码

完整代码如下

```c++
#include <iostream>
#include <vector>
#include <algorithm>
#include <sstream>
#include <string>
using namespace std;

//leetcode64
int minPathSum(vector<vector<int>>& grid) {
	int m = grid.size();
	int n = grid[0].size();

	// 创建一个与原矩阵相同大小的dp矩阵
	// dp[i][j]表示从grid[0][0]到grid[i][j]的最短路径和
	vector<vector<int>> dp(m, vector<int>(n, 0));

	//初始化dp
	dp[0][0] = grid[0][0];
	//初始化dp的第一列和第一行
	//由于只能往右或者往下，所以dp第一列或第一行就是上一位的累加
	//dp[i][0]只能由dp[i - 1][0]向下移动到达
	for (int i = 1; i < m; i++) {
		dp[i][0] = dp[i - 1][0] + grid[i][0];
	}
	//dp[0][j]只能由dp[0][j - 1]向右移动到达
	for (int j = 1; j < n; j++) {
		dp[0][j] = dp[0][j - 1] + grid[0][j];
	}

	for (int i = 1; i < m; i++) {
		for (int j = 1; j < n; j++) {
			//dp[i][j] = 从[i,j]的左边向右移动到达[i,j]的距离 和 从[i,j]的上边向下移动到达[i,j]的距离 的最小值
			dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
		}
	}

	return dp[m - 1][n - 1];
}

int maxPathSum(vector<vector<int>>& grid) {
	int m = grid.size();
	int n = grid[0].size();

	// 创建一个与原矩阵相同大小的dp矩阵
	vector<vector<int>> dp(m, vector<int>(n, 0));

	// 初始化第一行和第一列
	dp[0][0] = grid[0][0];
	for (int i = 1; i < m; ++i) {
		dp[i][0] = dp[i - 1][0] + grid[i][0];
	}
	for (int j = 1; j < n; ++j) {
		dp[0][j] = dp[0][j - 1] + grid[0][j];
	}

	// 动态规划计算每个位置的最大路径和
	for (int i = 1; i < m; ++i) {
		for (int j = 1; j < n; ++j) {
			//dp[i][j] = 从[i,j]的左边向右移动到达[i,j]的距离 和 从[i,j]的上边向下移动到达[i,j]的距离 的最大值
			dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
		}
	}

	// 返回右下角位置的最大路径和
	return dp[m - 1][n - 1];
}

int main() {
	string line;
	getline(cin, line);

	//解析line
	//列数是line的最后一位
	string sn = "";
	sn += line[line.size() - 1];
	int N = stoi(sn);
	//行数是line的倒数第三位（倒数第二位是 ','）
	string sm = "";
	sm += line[line.size() - 1 - 1 - 1];
	int M = stoi(sm);
	//解析出图的关联矩阵形式
	vector<vector<int>> grid(M, vector<int>(N));
	string str = "";
	//由于line的line[0]='[',所以下标i从1开始
	//line的最后一位是列数 倒数第二位是',' 倒数第三位是行号，倒数第四为是']'，所以下标的最大值是line.size()-5 
	for (int i = 1; i < line.size() - 1 - 1 - 1 - 1; i++) {
		str += line[i];
	}
	//最终获得的str就是关联矩阵的行表示，将其转换成矩阵的形式
	stringstream ss(str);
	for (int i = 0; i < M; i++) {
		for (int j = 0; j < N; j++) {
			string s;
			getline(ss, s, ',');
			grid[i][j] = stoi(s);
		}
	}

	int maxSum = maxPathSum(grid);
	cout << maxSum << endl;

	return 0;
}
```

## 2.动态规划

### 题目描述

小快的庄园有m个单位的容量，小快现在有n只帕鲁，第i只帕鲁需要v[i]单位的生存空间，第i只帕鲁的生产效率是e[i]，小快庄园的最大生产效率是多少?

- 输入

  ```c++
  15,5,[4,5,6,7,8],[5,6,7,8,9]
  ```

- 输出

  ```c++
  18
  ```

### 分析

本题是采用背包问题的经典题目，关于背包问题的解法可以看[代码随想录 ](https://www.programmercarl.com/背包理论基础01背包-1.html#思路)

### 代码

这里就不做输入解析了，关于输入解析的过程可以参考第一题

```c++
#include <iostream>
#include <vector>

using namespace std;

vector<int> weight = { 4, 5, 6, 7, 8 };
vector<int> value = { 5, 6, 7, 8, 9 };
int bagweight = 15;
int n = 5;
void solve() {
	// dp数组, dp[i][j]代表行李箱空间为j的情况下,从下标为[0, i]的物品里面任意取,能达到的最大价值
	vector<vector<int>> dp(weight.size(), vector<int>(bagweight + 1, 0));

	// 初始化, 因为需要用到dp[i - 1]的值
	// j < weight[0]已在上方被初始化为0
	// j >= weight[0]的值就初始化为value[0]
	for (int j = weight[0]; j <= bagweight; j++) {
		dp[0][j] = value[0];
	}

	for (int i = 1; i < weight.size(); i++) { // 遍历物品
		for (int j = 0; j <= bagweight; j++) { // 遍历行李箱容量
			// 如果装不下这个物品,那么就继承dp[i - 1][j]的值
			if (j < weight[i]) dp[i][j] = dp[i - 1][j];
			// 如果能装下,就将值更新为 不装这个物品的最大值 和 装这个物品的最大值 中的 最大值
			// 装这个物品的最大值由容量为j - weight[i]的包任意放入序号为[0, i - 1]的最大值 + 该物品的价值构成
			else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
		}
	}
	cout << dp[weight.size() - 1][bagweight] << endl;
}

int main() {
	solve();
	return 0;
}
```

## 3.滑动窗口最大值

这道题目是leetcode上的原题[239. 滑动窗口最大值 - 力扣（LeetCode）](https://leetcode.cn/problems/sliding-window-maximum/description/)

### 题目描述

给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。

返回 *滑动窗口中的最大值* 。

- 输入

  ```c++
  nums = [1,3,-1,-3,5,3,6,7], k = 3
  ```

- 输出

  ```c++
  [3,3,5,5,6,7]
  ```

### 分析

本题可以采用暴力解法，也就是每次滑动窗口向右移动一位时，就通过一个for循环找出当前窗口的最大值，显然这种方法的时间复杂度是`O(NK)`.

代码随想录中[代码随想录 (programmercarl.com)](https://www.programmercarl.com/0239.滑动窗口最大值.html#算法公开课)给出的方法是自己定义一个双端队列，保证队列中对头的元素永远是最大的。

### 代码

代码随想录中的方法如下

```c++
#include <iostream>
#include <vector>
#include <deque>
using namespace std;

class MyQueue {
public:
	deque<int> dq;

	// 每次弹出的时候，比较当前要弹出的数值是否等于队列出口元素的数值，如果相等则弹出。
	// 同时pop之前判断队列当前是否为空
	void pop(int value) {
		if (!dq.empty() && value == dq.front()) {
			dq.pop_front();
		}
	}

	//向dq中添加元素
	//在push元素的时候要判断value和队尾元素的关系，如果队尾元素<value，就弹出队尾元素，直至队尾元素>value或dq为空
	//添加元素的关键在于要保证对头的元素是最大的
	void push(int value) {
		while (!dq.empty() && value > dq.back()) {
			dq.pop_back();
		}
		dq.push_back(value);
	}

	//获取对头元素
	int front() {
		return dq.front();
	}
};

vector<int> maxSlidingWindow1(vector<int>& nums, int k) {
	vector<int> result;
	MyQueue que;
	//先将前k个元素添加至que中
	for (int i = 0; i < k; i++) {
		que.push(nums[i]);
	}
	//此时que的对头元素就是最大的
	result.push_back(que.front());

	for (int i = k; i < nums.size(); i++) {
		que.pop(nums[i - k]);//滑动窗口移除最前面元素
		que.push(nums[i]);//向窗口中添加一个元素
		result.push_back(que.front());//获取窗口中的最大值
	}

	return result;
}

int main() {
	int n, k;
	cin >> n >> k;

	vector<int> nums(n);
	for (int i = 0; i < n; ++i) {
		cin >> nums[i];
	}

	vector<int> result = maxSlidingWindow1(nums, k);
	for (int i = 0; i < result.size(); ++i) {
		cout << result[i] << " ";
	}
	cout << endl;

	return 0;
}
```

本题还有另外一种解法，来自GPT

关键点在于每次向队列中添加元素的之前，都要进行两步操作

- 删除当前已经不在窗口中的元素
- 删除对头元素中比需要插入的元素小的元素

```c++
vector<int> maxSlidingWindow1(vector<int>& nums, int k) {
	vector<int> result;
	deque<int> window; // 双端队列，用于存储索引

	for (int i = 0; i < nums.size(); ++i) {
		//为什么window.front() <= i - k
		// i表示当前窗口的右边界
		// k表示窗口内元素的个数
		// 由于边界是从0开始的
		// 右边界 - 左边界 >= k 就需要删除窗口元素
		// 左边界 <= 右边界 - k
		while (!window.empty() && window.front() <= i - k) {
			window.pop_front();
		}

		// 删除队列中比当前元素小的元素 保证对头元素是最大的
		while (!window.empty() && nums[window.back()] <= nums[i]) {
			window.pop_back();
		}

		window.push_back(i);

		// 当窗口完全覆盖时，记录窗口中的最大值
		if (i >= k - 1) {
			result.push_back(nums[window.front()]);
		}
	}

	return result;
}
```

可以说这三道题目都是leetcode上的原题，但是难度还是挺大的。

最后给自己的GitHub打一波广告[MyProject(github.com)](https://github.com/qlzhai?tab=repositories)